환영합니다

이 단계에서는 우리가 리스트 인터페이스와 그의 몇 가지 구현에 대해 배운 것을 복습해 보죠

리스트는 컬렉션 인터페이스를 연장합니다, 즉, 이것은 컬렉션 인터페이스에 있는 모든 것을 구현하고

거기에 더해서, 객체의 위치에 상관하는 메서드를 제공하죠

그래서, 리스트의 끝이나 중간, 어디든지 요소를 삽입할 수 있습니다

우리는 리스트 인터페이스를 보았고 여러 메서드도 보았습니다

indexOf도 보았죠, 혹시 여러분이 lastIndexOf를 찾으려면, 리스트에는

중복이 있을 수 있는 만큼 같은 요소가 세 개나 네 개 존재할 수도 있기 때문에

lastIndexof()는 이 특정 요소의 마지막 위치를 찾는 데도 쓰일 수 있습니다

우리는 리스트 인터페이스에 있는 다양한 메서드를 봤습니다

그리고 우리는 반복자와 리스트를 어떻게 리스트로 돌릴지도 봤죠

우리는 리스트 인터페이스의 세 가지 다른 구현도 보았습니다

하나는 ArrayList이죠, 배열을 기초적 데이터 구조로 사용하는 것입니다

이것은 LinkedList에 비해 삽입과 제거가 더 느리다는 의미입니다

하지만 특정 위치의 특정 요소에 접근하고 싶다면, 매우 빨리 수행할 수 있죠

LinkedList는

기반되는 데이터 구조는 doubly linkedlist인 linkedlist입니다, 즉, 앞뒤의 요소와

연결이 있는 것이죠 LinkedList의 특징은 반복하는 것과 특정 인덱스의 요소를 찾는 것은

ArrayList에 비해 훨씬 느리다는 겁니다

하지만, 요소의 삽입과 제거는 훨씬 빠르죠

Vector라는, 스레드-안전한 리스트의 구현도 살펴 보았습니다, Vector는 동기화된 메서드를 이용해

스레드 안전을 구현하죠

하지만, 다중 스레드 시나리오에서는 Vector는 성능 하락을 부를 수 있습니다, 왜냐하면

Vector의 모든 메소드들은 동기화되어 있으니까요

우리는 Vector의 스레드 안전에 대한 접근법인

동시적 컬렉션 에 대해서도 알아보도록 하겠습니다

스레드에 대해 이야기 한 다음 단계에서는, Set이라는 또다른 컬렉션 인터페이스에 대해 알아봅시다

다음 단계에서 뵙겠습니다.